# **5.面向对象编程(下)**  
## **5.1关键字:static**  
一、static:静态的  
二、static可以用来修饰：属性、方法、代码块、内部类  
三、使用static修饰属性:静态变量(或类变量)  
&emsp;&emsp;3.1属性，按是否使用static修饰，又分为:静态属性vs非静态属性(实例变量)  
&emsp;&emsp;&emsp;&emsp;实例变量:我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。  
&emsp;&emsp;&emsp;&emsp;静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。  
&emsp;&emsp;3.2static修饰属性的其他说明:  
&emsp;&emsp;&emsp;&emsp;①静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用  
&emsp;&emsp;&emsp;&emsp;②静态变量的加载要早于对象的创建。  
&emsp;&emsp;&emsp;&emsp;③由于类只会加载一次，则静态变量在内存中也只会存在一份:存在方法区的静态域中。  
&emsp;&emsp;3.3静态属性举例:System.out;Math.PI;  
四、使用static修饰方法:静态方法  
&emsp;&emsp;①随着类的加载而加载，可以通过"类.静态方法"的方式进行调用  
&emsp;&emsp;②在static方法内部只能访问类的static修饰的属性或方法， 不能访问类的非static的结构。  
五、static注意点:  
&emsp;&emsp;5.1在静态的方法内，不能使用`this`关键字、`super`关键字  
&emsp;&emsp;5.2关于静态属性和静态方法的使用，大家都从生命周期的角度去理解  
六、开发中，如何确定一个属性是否声明为static的？  
&emsp;&emsp;&emsp;&emsp;>属性是可以被多个对象所共享的，不会随着对象的不同而不同。  
&emsp;&emsp;&emsp;&emsp;>类中的常量也常常声明为static  
&emsp;&emsp;开发中，如何确定一个属性是否声明为static的？  
&emsp;&emsp;&emsp;&emsp;>操作静态属性的方法，通常设置为static的  
&emsp;&emsp;&emsp;&emsp;>工具类中的方法，习惯上声明为static的，比如:Math、Arrays、Collections  
七、单例设计模式:  
&emsp;&emsp;1.所谓类的单例设计模式，就是采用一定的方法在整个的软件系统中，对某一个类只能存在一个对象实例。  
&emsp;&emsp;2.如何实现？  
&emsp;&emsp;&emsp;&emsp;饿汉式:
```
        public class Singleton1 {
            private Singleton1() {
            }
            private static Singleton1 singleton = new Singleton1();
            public static Singleton1 getInstance() {
                return singleton;
            }
        }
```
&emsp;&emsp;&emsp;&emsp;懒汉式:
```
        public class Singleton2 {
            private Singleton2() {
            }
            private static Singleton2 singleton;
            public static Singleton2 getInstance() {
                if (singleton == null) {
                    singleton = new Singleton2();
                }
                return singleton;
            }
        }
```
&emsp;&emsp;3.区分饿汉式和懒汉式  
&emsp;&emsp;&emsp;&emsp;饿汉式:好处:线程安全;坏处:对象加载时间过长  
&emsp;&emsp;&emsp;&emsp;懒汉式:好处:延迟对象的创建;坏处:线程不安全  
&emsp;&emsp;4.应用场景:网站计数器、应用程序的日志应用、数据库连接池、读取配置文件的类、Application、windows的资源管理器、windows的回收站  
## **5.2理解main方法的语法**  
&emsp;&emsp;1.main()方法作为程序的入口  
&emsp;&emsp;2.main()方法也是一个普通的静态方法  
&emsp;&emsp;3.main()方法可以作为我们与控制台交互的方式  
## **5.3类的成员之四:代码块**  
&emsp;&emsp;1.代码块的作用：用来初始化类、对象  
&emsp;&emsp;2.代码块如果有修饰的话，只能使用static  
&emsp;&emsp;3.分类:静态代码块vs非静态代码块  
&emsp;&emsp;4.静态代码块  
&emsp;&emsp;&emsp;&emsp;内部可以有输出语句  
&emsp;&emsp;&emsp;&emsp;随着类的加载而执行，而且只执行一次  
&emsp;&emsp;&emsp;&emsp;作用:初始化类的信息  
&emsp;&emsp;&emsp;&emsp;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行  
&emsp;&emsp;&emsp;&emsp;静态代码块的执行要优先于非静态代码块的执行  
&emsp;&emsp;&emsp;&emsp;静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构  
&emsp;&emsp;5.非静态代码块  
&emsp;&emsp;&emsp;&emsp;内部可以有输出语句  
&emsp;&emsp;&emsp;&emsp;随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块  
&emsp;&emsp;&emsp;&emsp;作用:可以在创建对象时，对对象的属性进行初始化  
&emsp;&emsp;&emsp;&emsp;如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行  
&emsp;&emsp;&emsp;&emsp;非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法  
&emsp;&emsp;6.对属性可以赋值的位置:  
&emsp;&emsp;&emsp;&emsp;①默认初始化  
&emsp;&emsp;&emsp;&emsp;②显式初始化/在代码块中赋值  
&emsp;&emsp;&emsp;&emsp;③构造器中初始化  
&emsp;&emsp;&emsp;&emsp;④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值  
## **6.4关键字:final**  
final:最终的  
&emsp;&emsp;1.final可以用来修饰的结构:类、方法、变量  
&emsp;&emsp;2.final用来修饰一个类:此类不能被其他类所继承，比如:String类、System类、StringBuffer类  
&emsp;&emsp;3.final用来修饰方法:表明此方法不可以被重写，比如Object类中的getClass()  
&emsp;&emsp;4.final用来修饰变量:此时的"变量"就称为是一个常量  
&emsp;&emsp;&emsp;&emsp;4.1final修饰属性:可以考虑赋值的位置有:显式初始化、代码块中初始化、构造器中初始化  
&emsp;&emsp;&emsp;&emsp;4.2final修饰局部变量:尤其是使用final修饰形参时，表明此形参时一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。  
&emsp;&emsp;5.static final用来修饰属性:全局常量  
