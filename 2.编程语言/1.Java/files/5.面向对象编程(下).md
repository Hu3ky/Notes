# 5.面向对象编程(下)  
## 5.1 关键字:static  
1. static:静态的
2. static可以用来修饰：属性、方法、代码块、内部类
3. 使用static修饰属性:静态变量(或类变量)
   - 属性，按是否使用static修饰，又分为:静态属性vs非静态属性(实例变量)
     - 实例变量:我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。
     - 静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。
   - static修饰属性的其他说明:
     - 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用
     - 静态变量的加载要早于对象的创建。
     - 由于类只会加载一次，则静态变量在内存中也只会存在一份:存在方法区的静态域中。
   - 静态属性举例:System.out;Math.PI;
4. 使用static修饰方法:静态方法
   - 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用
   - 在static方法内部只能访问类的static修饰的属性或方法， 不能访问类的非static的结构。
5. static注意点:
   - 在静态的方法内，不能使用`this`关键字、`super`关键字
   - 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解
6. 开发中，如何确定一个属性是否声明为static的？
   - 属性是可以被多个对象所共享的，不会随着对象的不同而不同。
   - 类中的常量也常常声明为static
   - 开发中，如何确定一个属性是否声明为static的？
     - 操作静态属性的方法，通常设置为static的
     - 工具类中的方法，习惯上声明为static的，比如:Math、Arrays、Collections
7. 单例设计模式:
   - 所谓类的单例设计模式，就是采用一定的方法在整个的软件系统中，对某一个类只能存在一个对象实例。
   - 如何实现？
     - 饿汉式:
     ```
        public class Singleton1 {
            private Singleton1() {
            }
            private static Singleton1 singleton = new Singleton1();
            public static Singleton1 getInstance() {
                return singleton;
            }
        }
     ```
     - 懒汉式:
     ```
        public class Singleton2 {
            private Singleton2() {
            }
            private static Singleton2 singleton;
            public static Singleton2 getInstance() {
                if (singleton == null) {
                    singleton = new Singleton2();
                }
                return singleton;
            }
        }
     ```
   - 区分饿汉式和懒汉式
     - 饿汉式:好处:线程安全;坏处:对象加载时间过长
     - 懒汉式:好处:延迟对象的创建;坏处:线程不安全
   - 应用场景:网站计数器、应用程序的日志应用、数据库连接池、读取配置文件的类、Application、windows的资源管理器、windows的回收站
## 5.2 理解main方法的语法  
1. main()方法作为程序的入口
2. main()方法也是一个普通的静态方法
3. main()方法可以作为我们与控制台交互的方式
## 5.3 类的成员之四:代码块  
1. 代码块的作用：用来初始化类、对象
2. 代码块如果有修饰的话，只能使用static
3. 分类:静态代码块vs非静态代码块
4. 静态代码块
   - 内部可以有输出语句
   - 随着类的加载而执行，而且只执行一次
   - 作用:初始化类的信息
   - 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
   - 静态代码块的执行要优先于非静态代码块的执行
   - 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
5. 非静态代码块
   - 内部可以有输出语句
   - 随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块
   - 作用:可以在创建对象时，对对象的属性进行初始化
   - 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
   - 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法
6. 对属性可以赋值的位置:
   - 默认初始化
   - 显式初始化/在代码块中赋值
   - 构造器中初始化
   - 有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值
## 5.4 关键字:final  
final:最终的  
1. final可以用来修饰的结构:类、方法、变量
2. final用来修饰一个类:此类不能被其他类所继承，比如:String类、System类、StringBuffer类
3. final用来修饰方法:表明此方法不可以被重写，比如Object类中的getClass()
4. final用来修饰变量:此时的"变量"就称为是一个常量
   - final修饰属性:可以考虑赋值的位置有:显式初始化、代码块中初始化、构造器中初始化
   - final修饰局部变量:尤其是使用final修饰形参时，表明此形参时一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
5. static final用来修饰属性:全局常量
## 5.5 抽象类与抽象方法  
1. abstract:抽象的
2. abstract可以用来修饰的结构:类、方法
3. abstract修饰类:抽象类
   - 此类不能实例化
   - 抽象类中中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化的全过程)
   - 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作
4. abstract修饰方法:抽象方法
   - 抽象方法只有方法的声明，没有方法体
   - 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的
   - 若子类重写了父类中的所有的抽象方法后，此子类方可实例化。若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰
5. abstract使用上的注意点:
   - abstract不能用来修饰:属性、构造器等结构
   - abstract不能用来修饰私有方法、静态方法、final的方法、final的类
6. 抽象类的应用:模板方法的设计模式
   - 当功能内部一部分实现是确定的， 一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
   - 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。
## 5.6 接口(interface)  
1. 接口使用interface来定义
2. Java中，接口和类是病并列的的两个结构
3. 如何定义接口:定义接口中的成员
   - JDK7及以前:只能定义全局常量和抽象方法
     - 全局常量:`public static final`的，但是书写时，可以省略不写
     - 抽象方法:`public abstract`
   - JDK8:除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法
     - 接口中定义的静态方法，只能通过接口来调用
     - 通过实现类的对象，可以调用接口中的默认方法；如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
     - 如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法(类优先原则)
     - 如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写的此方法情况下，报错(接口冲突)，这就需要我们必须在实现类中重写此方法
     - 如何在子类(或实现类)的方法中调用父类、接口中被重写的方法，`接口.super.方法名`
4. 接口中不能定义构造器！意味着接口不可以实例化
5. Java开发中，接口通过让类去实现(implements)的方式来使用。
   - 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化
   - 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
6. Java类可以实现多个接口，弥补了Java单继承性的局限性
   - 格式：`class A extends B implements C,D,E`
7. 接口与接口之间可以继承，而且可以多继承
8. 接口的具体使用，体现多态性
9. 接口，实际上可以看做是一种规范
## 5.7 类的内部成员之五:内部类
1. Java中运行将一个类A声明在另一个类B中，则类A就是内部类，类B成为外部类
2. 内部类的分类：成员内部类(静态、非静态) vs 局部内部类(方法内、代码块内、构造器内)
3. 成员内部类:
   - 一方面，作为外部类的成员：
     - 调用外部类的结构
     - 可以用static修饰
     - 可以被4种不同的权限修饰
   - 另一方面，作为一个类：
     - 类内可以定义属性、方法、构造器等
     - 可以被final修饰，表示此类不能被继承，言外之意，不使用final，就可以被继承
     - 可以被abstract修饰
4. 关注如下的3个问题
   - 如何实例化成员内部类的对象
   - 如何在成员内部类中区分调用外部类的结构
   - 开发中局部内部类的使用