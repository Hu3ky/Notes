# 3.面向对象编程(上)  
## 3.1 面向过程与面向对象  
1. 面向过程(POP)与面向对象(OOP)：
   - 二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
2. 面向对象的三大特征：
   - 封装
   - 继承
   - 多态
## 3.2 类和对象  
1. 类(Class)和对象(Object)是面向对象的核心概念。
   - 类是对一类事物的描述，是抽象的、概念上的定义
   - 对象是实际存在的该类事物的每个个体，因而也称为实例(instance)
2. 属性与行为
   - 属性：对应类中的成员变量
   - 行为：对应类中的成员方法
3. 创建Java自定义类的步骤
   - 定义类（考虑修饰符、类名）
   - 编写类的属性（考虑修饰符、属性类型、属性名、初始化值）
   - 编写类的方法（考虑修饰符、返回值类型、方法名、形参等）
## 3.3 类的成员之一：属性(成员变量) vs 局部变量  
1. 相同点：
   - 定义变量的格式：数据类型 变量名 = 变量值
   - 先声明，后使用
   - 变量都有其对应的作用域
2. 不同点：
   - 在类中声明的位置的不同
     - 属性：直接定义在类的一对{}内
     - 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
   - 关于权限修饰符的不同
     - 属性：可以在声明属性时，指明其权限，使用权限修饰符，常用的权限修饰符：`private`、缺省、`protected`、`public`
     - 局部变量：不可以使用权限修饰符
3. 默认初始化值的情况
   - 属性：类的属性，根据其类型，都有默认初始化值。
     - 整型(byte、short、int、long)：0
     - 浮点型(float、double)：0.0
     - 字符型(char)：0
     - 布尔型(boolean)：false
     - 引用数据类型(类、数组、接口)：null
   - 局部变量：没有默认初始化值。
4. 在内存中加载的位置：
   - 属性：加载到堆空间中
   - 局部变量：加载到栈空间
## 3.4 类的成员之二：  
方法：描述类应该具有的功能。  
1. 方法的声明：权限修饰符 返回值类型 方法名(形参列表) {方法体}
2. 说明：
   - 关于权限修饰符：`private`、缺省、`protected`、`public`
   - 返回值类型：有返回值 vs 无返回值
     - 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用`return`关键字来返回指定类型的变量和常量。
     - 如果方法没有返回值，则声明方法时，用`void`来表示。通常，没有返回值的方法中，就不需要使用`return`。但是，如果使用的话，只能使用`return;`表示结束此方法的意思。
   - 方法名：属于标识符，遵循标识符的规则和规范。
   - 形参列表：方法可以声明0个、1个、或者多个形参。
     - 数据类型1 形参1,数据类型2 形参2,...
   - 方法体：方法功能的体现。
3. return关键字的使用：
   - 使用范围：使用在方法体中
   - 作用：
     - 结束方法
     - 针对于有返回值类型的方法，使用`return 数据`方式返回所要的数据。
   - 注意点：`return`关键字后面不可以声明执行语句。
4. 方法的使用中，可以调用当前类的属性或方法(特殊：方法A中又调用了方法A，称之为递归方法)，方法中不可以定义方法。
## 3.5 匿名对象  
1. 理解：创建的对象，没有显示的赋给一个变量名。即为匿名对象。
2. 特征：匿名对象只能调用一次。
## 3.6 方法的进阶  
1. 方法的重载
   - 重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
     - “两同一不同”：同一个类、相同的方法名、参数列表不同（参数个数不同、参数类型不同）。
   - 重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。
   - 在通过对象调用方法时，（方法名+参数列表）确定某一个指定的方法。
2. 可变个数的形参
   - jkd5.0新增的内容
   - 具体使用：
     - 可变个数形参的格式：`数据类型 ... 变量名`
     - 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个...
     - 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。
     - 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者之间不能共存。
     - 可变个数形参在方法的形参中，必须声明在末尾。
     - 可变个数形参在方法的形参中，最多只能声明一个可变形参。
3. 方法参数的值传递机制  
   - 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
   - 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。
4. 递归方法  
   - 递归方法：一个方法体内调用它自身。
   - 递归方法包含了一种隐式的循环，它会重复执行某种代码，但这种重复执行无须循环控制。递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似死循环。
## 3.7 面向对象特征之一：封装与隐藏  
1. 问题的引入：
   - 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)。此时，针对于属性就体现了封装性。
2. 封装性的体现：
   - 我们将类的属性私有化(private)，同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值。
3. 封装性的体现，需要权限修饰符来配合。
   - Java规定的4种权限（从小到大）：private、缺省、protected、pubilc
   - 用来修饰的4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
   - 用来修饰的4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类。修饰类的话，只能使用：缺省、pubilc
   - 总结：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。
## 3.8 类的成员之三：构造器（或构造方法）  
1. 构造器的作用：
   - 创建对象
   - 初始化对象的属性
2. 说明：
   - 如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器
   - 定义构造器的格式：权限修饰符 类名(形参列表){}
   - 一个类中定义的多个构造器，彼此构成重载
   - 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
   - 一个类中，至少会有一个构造器
## 3.9 关键字：this的使用  
1. this可以用来修饰、调用：属性、方法、构造器  
2. this修饰属性和方法：  
this理解为：当前对象或当前创建的对象  
   - 在类的方法中，我们可以使用“this.属性”或“this.方法”的方式，调用当前对象属性或方法。但是通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式，表明此变量时属性，而非形参。
   - 在类的方法中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法。但是通常情况下，我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式，表明此变量时属性，而非形参。
3. this调用构造器
   - 我们在类的构造器中，可以显式的使用“this(形参列表)”方式，调用本类中的其他构造器
   - 构造器中不能通过“this(形参列表)”方式调用自己
   - 如果一个类中有n个构造器，则最多有n-1个构造器使用了“this(形参列表)”
   - 规定：“this(形参列表)”必须声明在当前构造器的首行
   - 构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他的构造器
## 3.10 关键字：package、import的使用  
1. package关键字的使用
   - 为了更好的实现项目中类的管理，提供包的概念。
   - 使用package声明类或接口所属的包，声明在源文件的首行。
   - 包，属于标识符，遵循标识符的命名规则、规范、“见名知意”。
   - 每"."一次，就代表一层文件目录。
2. import关键字的使用
   - 在源文件中显式的使用import结构导入指定包下的类、接口
   - 声明在包的声明和类的声明之间
   - 如果需要导入多个结构，则并列写出即可
   - 可以使用“xxx.*”的方式，表示可以导入xxx包下的所有结构
   - 如果使用的类或者接口是java.lang包下定义的，则可以省略import结构
   - 如果使用的类或接口是本包下定义的，则可以省略import结构
   - 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示
   - 使用“xxx.”方式声明可以调用xxx包下的所有接口。但是使用的是xxx子包下的结构，则仍需要显式导入
   - import static：导入指定类或接口中的静态结构：属性或方法