# **4.面向对象编程(中)**  
## **4.1面向对象特征之二：继承性**  
一、继承性的好处：  
&emsp;&emsp;①减少了代码的冗余，提高了代码的复用性  
&emsp;&emsp;②便于功能的扩展  
&emsp;&emsp;③为以后多态性的使用，提供了前提  
二、继承性的格式：`class A extends B {}`  
&emsp;&emsp;A:子类、派生类、subclass  
&emsp;&emsp;B:父类、超类、基类、superclass  
&emsp;&emsp;体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性、方法  
&emsp;&emsp;2.1特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只是因为封装性的影响，使得子类不能直接调用父类的结构而已。  
&emsp;&emsp;2.2子类继承父类以后，还可以声明自己特有的属性和方法，实现功能的扩展。  
&emsp;&emsp;2.3子类和父类的关系，不同于子集和集合的关系。  
三、Java中关于继承性的规定：  
&emsp;&emsp;1.一个类可以被多个子类继承。  
&emsp;&emsp;2.Java中类的单继承性：一个类只能有一个父类。  
&emsp;&emsp;3.子父类是相对的概念。  
&emsp;&emsp;4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类。  
&emsp;&emsp;5.子类继承父类之后，就获取了直接父类以及间接父类中声明的属性和方法。  
四、  
&emsp;&emsp;1.如果我们没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类  
&emsp;&emsp;2.所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类  
&emsp;&emsp;3.意味着，所有的java类具有java.lang.Object类声明的功能  
## **4.2方法的重写(override/overwrite)**  
一、重写的定义：  
&emsp;&emsp;子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作  
二、重写的应用：  
&emsp;&emsp;重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法  
三、重写的规定：  
&emsp;&emsp;方法的声明：权限修饰符&emsp;返回值类型&emsp;方法名(形参列表)&emsp;throws&emsp;异常的类型{方法体}  
&emsp;&emsp;约定俗称：子类的叫重写的方法，父类中的叫被重写的方法  
&emsp;&emsp;①子类重写的方法的方法名和形参列表与父类中被重写的方法的方法名和形参列表相同  
&emsp;&emsp;②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符(特殊情况：子类不能重写父类中声明为private权限的方法)  
&emsp;&emsp;③返回值类型：  
&emsp;&emsp;&emsp;&emsp;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void  
&emsp;&emsp;&emsp;&emsp;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类  
&emsp;&emsp;&emsp;&emsp;父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型  
&emsp;&emsp;④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放到异常处理时候再讲)  
四、注意：子类和父类的同名同参数的方法要么都声明为非static的(考虑重写)，要么都声明为static的(不是重写)  
## **4.3关键字：super**  
一、super理解为：父类的  
二、super可以用来调用：属性、方法、构造器  
三、super的使用：调用属性和方法  
&emsp;&emsp;3.1我们可以在子类的方法或构造器中。通过使用“super.属性”或“super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.”  
&emsp;&emsp;3.2特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用“super.属性”的方式，表明调用的是父类中声明的属性。  
&emsp;&emsp;3.3特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用“super.方法”的方式，表明调用的是父类中被重写的方法。  
四、super调用构造器  
&emsp;&emsp;4.1我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的指定的构造器  
&emsp;&emsp;4.2“super(形参列表)”的使用，必须声明在子类构造器的首行！  
&emsp;&emsp;4.3我们在类的构造器中，针对于“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现  
&emsp;&emsp;4.4在构造器的首行，没有显式的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参的构造器：super()  
&emsp;&emsp;4.5在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用了父类中的构造器  
五、子类对象实例化过程  
&emsp;&emsp;1.从结果上来看：(继承性)  
&emsp;&emsp;&emsp;&emsp;子类继承父类以后，就获取了父类中声明的属性或方法  
&emsp;&emsp;&emsp;&emsp;创建子类的对象，在堆空间中，就会加载所有父类中声明的属性  
&emsp;&emsp;2.从过程上来看：  
&emsp;&emsp;&emsp;&emsp;当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑调用。  
&emsp;&emsp;明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。  
## **4.4面向对象特征之三：多态性**  
一、理解多态性：可以理解为一个事物的多种形态。  
二、何为多态性：  
&emsp;&emsp;对象的多态性：父类的引用执行子类的对象(或子类的对象赋给父类的引用)  
三、多态的使用：虚拟方法调用  
&emsp;&emsp;有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。  
&emsp;&emsp;总结：编译看左边；运行看右边  
四、多态性的使用前提：  
&emsp;&emsp;①类的继承关系  
&emsp;&emsp;②方法的重写  
五、对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边)  
## **4.5instanceof关键字的使用**  
一、a instanceof A：判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false  
二、使用情景：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。  
三、如果a instanceof A返回true，则a instanceof B也返回true。其中，类B是类A的父类。  
## **4.6Object类的使用**  
一、Object类是所有Java类的根父类  
二、如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类  
三、Object类中的功能(属性、方法)具有通用性  
&emsp;&emsp;属性：无  
&emsp;&emsp;方法：equals()/tostring()/getclass()/hashcode()/clone()/finalize()/wait()、notify()、notifyAll()  
四、Object类只声明了一个空参的构造器  
## **4.7包装类的使用**  
一、Java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征  
二、掌握的：基本数据类型、包装类、Strings三者的相互转换  


